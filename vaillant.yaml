esphome:
  name: vaillantvkk226
  friendly_name: vaillantvkk226
  includes:
    ##- vaillantx6mod.h  # Einbindung der Datei vaillantx6mod.h
    - vaillantx6.h  # Einbindung der Datei vaillantx6.h    
esp32:
  board: esp32dev
  framework:
    #type: arduino
    type: esp-idf  # Verwendetes Framework (ESP-IDF)

# Enable logging
logger:  # Aktivierung des Loggers

# Enable Home Assistant API
api:
  encryption:
    key: "BlLq6K7NH3wmHlVg9Z9L/nGEsJN4/9jgRmIQogqMybE="

web_server:
  port: 80  # Web-Server-Port
  #auth:
    #username: admin
    #password: test1234

ota:
  - platform: esphome
    password: "acc60f0ee262fbd990522f0428d6fd9a"

wifi:
  ssid: !secret wifi_ssid  # WiFi-SSID aus geheimen Variablen
  password: !secret wifi_password  # WiFi-Passwort aus geheimen Variablen

# Enable fallback hotspot (captive portal) in case wifi connection fails
  #ap:
  # ssid: "Vaillant2P Fallback Hotspot"
# password: "S1UbAwCfw9HX"

#captive_portal:

switch:
  - platform: restart
    name: "Restart"  # Restart-Schalter

#text_sensor:
  #- platform: debug
   # reset_reason:
    #  name: "Reset Reason"

sensor:
  - platform: uptime
    id: vaillant_uptime
    name: Vaillant Uptime  # Uptime-Sensor
    unit_of_measurement: "s"
  - platform: wifi_signal
    id: wifi_signal_percent
    name: "WiFi Signal"  # WiFi-Signalstärke-Sensor
    # wifi_signal is reported as signal strength/RSSI in dB
    # convert to percent via filter
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    update_interval: 60s
    entity_category: "diagnostic"
    device_class: ""

# Temperaturen
  - name: "Vorlauf ist HK1"
    id: vaill0
    platform: template
    #icon: "mdi:heating-coil"
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"

  - name: "Speichertemperatur ist"
    id: vaill1
    platform: template
    icon: "mdi:water-boiler"
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"

  - name: "Vorlauf Soll HK2"
    id: vaill2
    platform: template
    icon: "mdi:heating-coil"
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"


#Sensor 1 byte
  - name: "Brennersperrzeit" # 1 byte 38
    id: byte1_vaill0
    platform: template
    icon: "mdi:fire-off"
    unit_of_measurement: "min"
    update_interval: 30s
    lambda: "return {};"


# Sensor 2 byte
  - name: "Brennerstarts Heizen orig"
    id: byte2_vaill0
    platform: template
    update_interval: 120s
    #accuracy_decimals: 0
    lambda: "return {};"    
    
  - name: "Brennerstarts Heizen"
    platform: template    
    #update_interval: 10s
    lambda: |-
      return id(byte2_vaill0).state*100;

  - name: "Brennerstarts für Warmwasser orig"
    id: byte2_vaill1
    platform: template
    #update_interval: 120s
    lambda: "return {};"   


  - name: "Brennerstarts für Warmwasser"
    platform: template    
    #update_interval: 10s
    lambda: |-
      return id(byte2_vaill1).state*100;


  - name: "Gebläse Drehzahl"
    id: byte2_vaill2
    platform: template
    icon: "mdi:car-turbocharger"
    unit_of_measurement: "rpm"
    update_interval: 120s
    accuracy_decimals: 0
    lambda: "return {};"  


  - name: "HeizLeistung"
    platform: template    
    icon: "mdi:speedometer"
    unit_of_measurement: "%"
    update_interval: 30s
    lambda: |-
      return id(byte2_vaill2).state/5400*100;//5358

  - name: "Stunden bis Wartung"
    id: byte2_vaill3
    platform: template
    icon: "mdi:timer-sand"
    unit_of_measurement: "h"
    update_interval: 120s
    #accuracy_decimals: 0
    lambda: "return {};"  


binary_sensor:
  - name: "Brenner"
    id: bvaill0
    icon: "mdi:fire"
    platform: template
    lambda: "return {};"

  - name: "Zirkulation"
    id: bvaill1
    icon: "mdi:water-pump"
    platform: template
    lambda: "return {};"
    
  - name: "Speicherladepumpe not"
    id: bvaill2
    platform: template
    lambda: "return {};"

  - name: "Speicherladepumpe"
    platform: template    
    icon: "mdi:pump"
    lambda: |-
      return !id(bvaill2).state;  // Invertiere den Zustand des Sensors

# Wenn die geschweiften Klammern ({}) in der Lambda-Funktion für dich funktionieren, bedeutet das, dass die Klasse Vaillantx6 bereits die Sensorwerte korrekt an die template-Sensoren übergibt.

custom_component:
- lambda: |-
    auto vx6 = new Vaillantx6(id(x6_uart),
                              id(vaill0),id(vaill1),id(vaill2),
                              id(byte1_vaill0),//id(byte1_vaill1),id(byte1_vaill2),
                              id(byte2_vaill0),id(byte2_vaill1),id(byte2_vaill2),id(byte2_vaill3),
                              id(bvaill0),id(bvaill1),id(bvaill2));                     
    App.register_component(vx6);
    return {vx6};  // Registrierung der benutzerdefinierten Komponente Vaillantx6

uart:
  id: x6_uart
  tx_pin: GPIO17  # UART TX-Pin
  rx_pin: GPIO16  # UART RX-Pin
  baud_rate: 9600
