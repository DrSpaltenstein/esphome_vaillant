esphome:
  name: vaillantvkktest
  friendly_name: vaillantvkktest
  includes:
    - vaillantx6mod.h  # Einbindung der Datei vaillantx6.h
esp32:
  board: esp32dev
  framework:
    #type: arduino
    type: esp-idf  # Verwendetes Framework (ESP-IDF)

# Enable logging
logger:  # Aktivierung des Loggers

# Enable Home Assistant API
api:
  encryption:
    key: "pzoRsVCmlqF/bRS8wAV3qS1bjkAG+PfBYz9aCo9UG1c="

web_server:
  port: 80  # Web-Server-Port
  #auth:
    #username: admin
    #password: test1234

ota:
  - platform: esphome
    password: "e3f0de663b7710882baf210db3c6174b"

wifi:
  ssid: !secret wifi_ssid  # WiFi-SSID aus geheimen Variablen
  password: !secret wifi_password  # WiFi-Passwort aus geheimen Variablen

# Enable fallback hotspot (captive portal) in case wifi connection fails
  #ap:
  # ssid: "Vaillant2P Fallback Hotspot"
# password: "S1UbAwCfw9HX"

#captive_portal:

switch:
  - platform: restart
    name: "Vaillant Restart"  # Restart-Schalter

#text_sensor:
  #- platform: debug
   # reset_reason:
    #  name: "Reset Reason"

sensor:
  - platform: uptime
    id: vaillant_uptime
    name: Vaillant Uptime  # Uptime-Sensor
    unit_of_measurement: "s"
  - platform: wifi_signal
    id: wifi_signal_percent
    name: "WiFi Signal"  # WiFi-Signalstärke-Sensor
    # wifi_signal is reported as signal strength/RSSI in dB
    # convert to percent via filter
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    update_interval: 60s
    entity_category: "diagnostic"
    device_class: ""

  - name: "Vorlauf ist HK1"
    id: vaill0
    platform: template
    icon: "mdi:water-percent"
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"

  - name: "Vorlauf set HK1"
    id: vaill1
    platform: template
    unit_of_measurement: "°C"
    device_class: "temperature"
    update_interval: 120s
    lambda: "return {};"

  - name: "Vorlauf soll HK2"
    id: vaill2
    platform: template
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"

  - name: "Vorlauf Soll HK2 2 temp"
    id: vaill3
    platform: template
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"

  - name: "Speichertemperatur ist"
    id: vaill4
    platform: template
    unit_of_measurement: "°C"
    update_interval: 120s
    lambda: "return {};"

# Sensor 1 byte
  - name: "Brennersperrzeit 1 byte 38"
    id: byte1_vaill0
    platform: template
    unit_of_measurement: "h"
    update_interval: 120s
    lambda: "return {};"

  - name: "Heizungsteillast kW 6C"
    id: byte1_vaill1
    platform: template
    unit_of_measurement: "kW"
    update_interval: 120s
    lambda: "return {};"

# Sensor 2 byte
  - name: "Heizstunden 28"
    id: byte2_vaill0
    platform: template
    unit_of_measurement: "h"
    update_interval: 120s
    accuracy_decimals: 0
    lambda: "return {};"    

  - name: "Brennerstarts Heizen 29"
    id: byte2_vaill1
    platform: template
    update_interval: 120s
    lambda: "return {};"   

  - name: "Drehzahl Gebläse soll 24"
    id: byte2_vaill2
    platform: template
    unit_of_measurement: "rpm"
    update_interval: 120s
    accuracy_decimals: 0
    lambda: "return {};"  

  - name: "Heizstunden3byte"
    id: byte3_vaill0
    platform: template
    unit_of_measurement: "rpm"
    update_interval: 120s
    accuracy_decimals: 0
    lambda: "return {};"  



binary_sensor:
  - name: "Brenner"
    id: bvaill0
    platform: template
    lambda: "return {};"
  - name: "NOT Speicherladepumpe 44"
    id: bvaill1
    platform: template
    lambda: "return {};"
  - name: "Status Unbekannt 4D"
    id: bvaill2
    platform: template
    lambda: "return {};"
  - name: "Status Unbekannt 4E"
    id: bvaill3
    platform: template
    lambda: "return {};"

  - name: "Speicherladepumpe"
    platform: template    
    lambda: |-
      return !id(bvaill1).state;  // Invertiere den Zustand des Sensors

custom_component:
- lambda: |-
    auto vx6 = new Vaillantx6(id(x6_uart),
                              id(vaill0),id(vaill1),id(vaill2),id(vaill3), id(vaill4),
                              id(byte1_vaill0),id(byte1_vaill1),
                              id(byte2_vaill0),id(byte2_vaill1),id(byte2_vaill2),
                              id(byte3_vaill0),
                              id(bvaill0),id(bvaill1),id(bvaill2),id(bvaill3));                        
    App.register_component(vx6);
    return {vx6};  // Registrierung der benutzerdefinierten Komponente Vaillantx6

# climate:
#   - platform: pid
#     id: vaillant_pid
#     name: "PID Vorlauf"
#     sensor: pid_vorlauf_input
#     heat_output: vaillant_789
#     default_target_temperature: "50°C"
#     visual:
#       min_temperature: 20
#       max_temperature: 80
#       temperature_step: 1
#     control_parameters:
#       output_averaging_samples: 3
#       # No Overshoot PID
#       kp: 0.00460
#       ki: 0.00046
#       kd: 0.02878
#     deadband_parameters:
#       threshold_high: 0.9°C
#       threshold_low: -0.9°C
#       kp_multiplier: 0.0   # proportional gain turned off inside deadband
#       ki_multiplier: 0.05  # integral accumulates at only 5% of normal ki
#       kd_multiplier: 0.0   # derviative is turned off inside deadband
#       deadband_output_averaging_samples: 15   # average the output over 15 samples within the deadband

uart:
  id: x6_uart
  tx_pin: GPIO17  # UART TX-Pin
  rx_pin: GPIO16  # UART RX-Pin
  baud_rate: 9600

# output:
#   - platform: ledc
#     pin: GPIO27
#     id: vaillant_789
#     frequency: 30kHz
#     zero_means_zero: true
#     min_power: 0.1
#     max_power: 0.8